\section{概述}\label{sec:overview}

\subsection{威胁模型}

在微服务安全计算场景中，可能的攻击方式和应对手段包括：

\begin{itemize}
    \item \textbf{系统特权态攻击}：攻击者可以通过攻击操作系统或者Hypervisor来获取系统的特权态，从而获取系统中的所有信息。但是，由于TEE是一种硬件保护机制，因此攻击者无法通过软件攻击来获取TEE中的信息，即使OS或HyperVisor被攻击，TEE中的信息也是安全的。
    \item \textbf{网络攻击}：包括中间人攻击（MITM）和重放攻击（Replay Attack）等。这种攻击方式可以通过网络安全协议等方式来防止。
    \item \textbf{漏洞利用}：主要是使用系统编程语言可能带来的缓冲区溢出攻击。这种攻击方式可以通过使用Rust提供静态安全检查来防止。
    \item \textbf{物理攻击}：如侧信道攻击是通过监测目标设备的非正常数据流或物理性能（如功耗、热量等）来获取设备中存储的敏感信息的攻击方式，这种攻击方式TEE本身无法防御，但是可以通过在软件中加入一些随机的操作来减少遭到攻击的可能。其他物理攻击包括电磁攻击通过高能电磁波或者电磁干扰对计算机或通信设备进行攻击、拒绝服务攻击通过破坏电源等方式让微服务宕机等，但是这些方式不会造成数据泄露，且应该是在微服务提供商层面进行防御。
\end{itemize}

本次研究的目的是防御系统特权态攻击、网络攻击和漏洞攻击，但是不考虑极端情况下的物理攻击。为了达到这一目的，本次设计具有以下信任假设：

\begin{itemize}
    \item \textbf{硬件可信}：硬件是可信的，即硬件不会对软件进行攻击，也不会泄露软件中的信息，硬件制造商不会在硬件中预置后门，系统不会遭到硬件攻击。
    \item \textbf{SGX可信}：SGX提供的所有机制都是可信的，包括SGX的内存加密、飞地的创建、飞地的隔离、SGX远程验证协议等。
    \item \textbf{平台可信}：项目平台本身的实现是可信的，包括微服务的运行时、通信协议的实现是正确无误的，且没有恶意代码。
    \item \textbf{Rust工具链可信}：Rust工具链是可信的，即Rust程序在构建过程中不会对代码进行恶意修改。
    \item \textbf{开发者基本可信}：通过非技术手段的约束，开发者不会在代码中预置后门，且不会使用不安全的编程语言；但开发者的代码可能存在bug。
    \item \textbf{PaaS系统不可信}：PaaS上的Hypervisor和OS是不可信的，可能存在恶意、被劫持或系统漏洞。
    \item \textbf{网络不可信}：网络通信是不可信的，可能存在中间人攻击、重放攻击等。
\end{itemize}

基于以上威胁模型和信任假设，我们对平台进行了以下设计：

\subsection{设计总览}

为了防止可能的攻击，同时尽可能减少编程bug带来的影响、减小TCB并降低通信延迟，我们针对微服务场景设计了细粒度、模块化的运行时，并设计了安全高效的远程验证协议，同时采用安全编程语言在TEE中进行实现，最终设计了一个安全高效为服务计算平台。

% 插入架构图

图\ref{}展示了平台的综合架构。最外层的框代表硬件基础，其上分别运行着操作系统和和Enclave中的程序。将Enclave放大，内部结构基于Graphene的结构，如图\ref{}所示。作为一个典型的LibOS，Graphene的结构类似于普通的进程，但是在库区域会有特殊的oslib，提供操作系统的支持；但是我们同时借鉴了Rust-SGX的思想，在编译阶段将一些操作利用Rust-SGX提供的编译方法编译进程序中，这样可以减少对OS的依赖，从而可以进一步缩减Graphene为Rust-SGX不能支持的功能集合。我们将Rust-SGX不能支持的部分划分为模块，开发者可以根据自己开发节点的需要选择需要的模块进行编译，由此得到了一个模块化、小TCB的运行时。

节点之间的通信使用gRPC，并使用自行设计的远程验证和安全通信协议进行保护。此外我们还借助了Intel SGX提供的远程验证机制，对节点的身份等进行验证，综合组成了完整的远程验证协议。

节点上运行的程序即为使用Rust语言编写的微服务示例程序。

\subsection{运行时设计}

在设计运行时之前，我们要明白为什么需要设计一个运行时，现有的方法在微服务计算平台场景下有什么缺陷。由于SGX是一种硬件层面的支持，虽然Intel官方提供了一套开发工具SDK~\cite{}，但是类似于使用C进行裸机编程，想要运行应用必须按照其规范重新编写。这样的编程方式对于开发者来说是不友好的，因此我们需要一个运行时来屏蔽底层的细节，提供类似于POSIX的接口给开发者使用。

目前的运行时设计主要有两种思路。第一种是在SGX中运行一个小型的操作系统，比如Microkernel（例如Keystone的XXX~\cite{}）或LibOS（例如Graphene-SGX~\cite{}、XXX~\cite{}等），这样可以在无改动或极少改动的情况下将现有程序运行在SGX中；但是即使是LibOS也包含较多的代码，具有较大的TCB，可能存在较多漏洞和较大的攻击面。第二种思路是针对特定编程语言编写SGX内的运行时库（例如Rust-SGX~\cite{}、（SGX中的libc）~\cite{}等），这样在编译生成的程序类似于使用SGX SDK开发的程序，可以在SGX中直接运行，由此可以达到很小的额外TCB；但是这种方式需要针对每种编程语言进行开发，且有些操作系统功能的实现非常困难（例如并发）。

我们的设计思路是将两种思路结合起来，同时兼顾两种思路的优点。考虑到微服务的特点，由于微服务的每个节点都很小，一般只需要操作系统提供的部分功能（例如网络），因此可以将LibOS进行拆分，将语言运行时库不能支持的功能按模块划分，达到按需引入的效果；同时虽然微服务架构是异构性的，但是每个节点往往都是由一种编程语言编写的，因此牺牲运行时的多语言支持是合理的。具体来说，我们从Graphene中拆分出Rust-SGX不能支持的功能，并尽量划分为独立的模块，开发者首先使用Rust-SGX提供的工具链编译出Object文件，然后与Graphene拆分得到的需要的模块进行链接，最终得到可以在SGX中运行的程序。由此可以减少不必要的系统功能，从而减小TCB，最终减小了攻击面，提高了系统安全性。

\subsection{远程验证协议设计}

设计远程验证协议是为了解决安全计算微服务场景下通信上的挑战，主要包含用户端和服务端的验证、微服务节点间首次通信验证对方的身份和合法性、微服务节点间每次通信保护机密性和完整性、依赖节点间授权合法性的验证等。因此，我们进行了以下设计：

\begin{itemize}
    \item \textbf{用户身份验证和鉴权}：即用户在使用服务功能时，服务端要对用户身份信息进行认证，并鉴定用户所具有的权限，以决定是否允许用户使用服务功能。这一问题其实是SOA固有的问题，目前已经有比较成熟的解决方案，例如OAuth2~\cite{}等。由于此问题不是本次研究主要面对的问题，因此本次设计暂不考虑。
    \item \textbf{微服务节点间首次通信验证对方的身份和合法性}：这一点主要是确认对方未被恶意篡改、身份合法且运行在合法的SGX飞地中。一般我们认定运行在SGX中的程序不会被篡改，因此这一验证的目的是确保对方节点已被SGX保护，并在加载进入SGX之前未遭到篡改。在这种情况下，为了减少远程验证的开销，我们可以只在新节点第一次通信时进行验证，元数据变更（例如重新启动、更新升级等）的节点视作新节点。由于SGX提供了强大的远程验证机制，足够达到我们的需求，因此我们可以在此机制的基础上完善设计。具体来说，每个节点都会维护一个信任白名单（T1），记录所有合法的节点的地址（IP和端口号）到身份信息（ID）的映射，ID包括其MRENCLAVE、MRSIGNER、公钥等；每次发送请求时都需要将自己的ID发送给对方，对方会检查其ID是否在T1中，如果不在，则会发起SGX远程验证，验证通过后将其加入T1。由于节点重启或更新后会生成新的ID，因此会自动重新进行远程验证并更新ID。为防止出现地址变化导致表中记录弃用，导致内存占用，可以适当限制T1的大小，并使用LRU~\cite{}算法清理弃用项。由于平台不存在恶意泄露ID的后门，进出SGX的数据也都会进行加密，因此攻击者无法窃取或伪造ID，这一验证机制是安全的。% 太大？LRU
    \item \textbf{微服务节点间每次通信保护机密性和完整性}：这种情况其实是网络通信固有的问题，但是由于微服务场景下额外增加了应用内部节点间的网络通信，扩大了网络攻击的攻击面。如果节点间通信不进行安全检查，一旦攻击者得到了节点的地址，就可以发起各种网络攻击。这一问题其实可以采用成熟的网络解决方案，例如使用TLS~\cite{}；但是TLS等方案需要在通信之前进行握手，造成额外的通信开销，即使使用最新的TLS1.3也需要1-RTT进行握手~\cite{}，而使用0-RTT的状态恢复则条件苛刻且有重放攻击的安全隐患。在微服务场景中，与TLS的传统使用场景（如HTTPS）相比，我们观察到了以下2点现象：(1) 一个微服务节点只会和有依赖关系的固定的节点进行通信，这些节点的数量远远少于Web应用下HTTPS面对的客户端数量；(2) 一个微服务节点的生命周期很长，一般只在重启或更新时才会改变地址，而Web应用下HTTPS面对的客户端的生命周期很短，一般只有几分钟；(3) 在有SGX保护的情况下，可以认为对称密钥是不会泄露的。因此，我们可以在微服务场景下借鉴0-RTT的状态恢复思路，即在第一次通信时进行握手，之后的通信都可以直接使用。但是与0-RTT不同的是，在微服务场景下我们是可以使用计数器来防备重放攻击的，而不会受到0-RTT方式下Anti-Replay~\cite{}等方式的限制。具体来说，我们添加另一个通信白名单（T2），记录通信过的节点的地址（IP和端口号）到对称密钥和计数器的映射，每次请求时先检查T2中是否有对方的记录，如果没有则需要先与对方使用DH算法~\cite{}进行密钥协商，双方都将计算出的对称密钥加入自己的T2中，之后进行通信；如果已有记录，则可以跳过DH握手直接进行通信。正式通信时要加入用对称密钥加密的身份信息，并使用计数器防止重放攻击。由于平台不存在恶意泄露对称密钥的后门，攻击者无法窃取对称密钥，这一通信机制是安全的；且因为避免了重复握手，这个方案是高效的。
          % 具体来说，我们可以在每个节点中维护一个密钥对，用于对通信内容进行加密和解密，每次通信时都会将自己的公钥发送给对方，对方会将其加入白名单。由于平台不存在恶意泄露密钥的后门，进出SGX的数据也都会进行加密，因此攻击者无法窃取密钥，这一验证机制是安全的。
    \item \textbf{依赖节点间授权的合法性}：这里是为了保障微服务节点间能够进行细粒度的认证和授权，以防止攻击者窃取授权造成隐私扩散。在4种不同的基于Token的验证思路中，只有Token交换的方式可以实现细粒度和更高级别的安全保障，虽然会带来额外的计算开销，但是作为聚焦于安全的研究，我们选择这种更安全的方案，同时因为微服务的瓶颈是通信开销，额外JWT计算带来的开销是很小的，因此这一方案是可行的。
\end{itemize}

在以上设计下，两个微服务节点第一次通信的示意如图XXX所示。
% TODO：图

\begin{enumerate}
    \item 请求方A检查自己的T2中是否有被请求方B的记录，如果没有则进行DH握手（握手过程参考TLS1.3实现）。此时第一次通信一定没有记录，因此A发送握手请求，其中包含DH算法公开参数等信息。
    \item B返回握手响应，双方分别计算出对称密钥，并将对方的地址和对称密钥记录到自己的T2中，握手完成。
    \item A向B发送加密的请求信息，其中包含计数器值、A的ID、上级节点传入的JWT加工得到的新JWT（如有）、请求内容等信息。
    \item B收到请求后，要做3层检查：(1) 检查计数器值是否合法，如果合法则更新计数器，否则拒绝请求。(2) 检查JWT中的身份和授权是否合法且有相应的权限，否则拒绝请求。(3) 检查自己的T1中是否有A的记录，如果没有则发起SGX远程验证，在IAS验证通过后将A的ID加入T1；远程验证不通过则拒绝请求。3层检查之间没有先后关系，因此为了加快速度可以考虑并行验证，此处为方便实现暂时分步进行。如果验证都通过，则将请求内容发送给上层应用层协议（例如gRPC、HTTP）处理。
    \item B执行完计算后将处理结果用对称密钥加密后返回给A，通信完成。
\end{enumerate}

\subsection{微服务示例程序设计}

为了后续实验验证我们的设计，我们还要设计一个简单的微服务示例程序。然而，由于Rust是一种新兴的编程语言，目前还没有使用Rust语言编写的开源微服务应用；已有的其他语言实现的微服务基准（例如Death~\cite{}和uSuite~\cite{}等）难以用Rust重写，且不是很符合安全计算的场景特点。因此，我们针对微服务安全计算的场景，设计了一个简单的图像处理相关的微服务示例程序。
