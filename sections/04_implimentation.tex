\section{平台实现}\label{sec:implimentation}

我们简单实现了\cref{sec:overview}中所述的设计，受限于工程能力和时间，我们对一些不重要但比较复杂的部分进行了简化，重点是使实现的平台能够表达出一个简单但接近真实的场景，以此说明设计的安全性和合理性，并对性能进行初步的测试。

\paragraph{运行时实现}

由于本次设计的微服务示例程序用到的操作系统支持很少，因此我们在Graphene-SGX~\cite{tsai2017graphene}的基础上删掉了大部分操作系统的特性，只保留了能够支持微服务运行的最小功能，包括网络通信、内存管理、远程验证等，由此作为运行时实现。
% 我们将这个运行时实现命名为Graphene-SGX-Micro，它的代码量约为Graphene-SGX的1/10。

\paragraph{远程验证协议实现}

向SGX IAS请求远程验证是Graphene-SGX中已实现的功能，因此不用进行实现。

而由于安全通信协议是本次研究中针对微服务安全计算场景设计的，因此我们需要自己实现。我们按照协议中设计的流程，简单实现了这一协议，实现形式为一个Rust crate，并将其封装为库的形式，供程序进行链接与使用。在通信的检查部分，为了方便实现，2层检查并没有采用并行的方式，而是按照顺序依次进行。

因为实现一个完整的通信协议库需要考虑很多细节（例如OpenSSL~\cite{openssl}），而本次实现不着重讨论这些细节，因此不能保证库的实现是安全的，不能用于生产场景。

\paragraph{微服务示例实现}

我们按照\cref{subsec:ms-example}中的微服务设计，使用Rust的gRPC库Tonic~\cite{tonic}实现了除数据持久化节点之外的所有微服务节点，并使用jsonwebtoken库生成和验证JWT，用来实现基于Token交换的授权机制。数据持久化节点暂时使用开源的Redis~\cite{redis}进行模拟。

为了进行测试，我们还实现了一个简单的客户端程序，用来模拟用户的请求。为简化处理，客户端和API网关之间的通信也使用了gRPC协议，而不是客户端和服务端交互下更常用的HTTP协议。
