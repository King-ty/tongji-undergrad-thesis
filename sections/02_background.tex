\section{背景}\label{sec:background}

\subsection{微服务}
微服务（Microservice）是一种基于服务架构（Service-Oriented Architecture，SOA）的软件设计风格和架构模式，将单一应用（Monolithic）程序拆分为一组独立的、小型的微服务，每个微服务都可以独立开发、部署、扩展、升级，已被广泛应用于云计算、容器化、DevOps等领域，是现代软件开发中的重要架构之一。

相比于传统的单一服务模式，微服务主要具备以下的优势：

\begin{itemize}
    \item \textbf{模块化}：微服务节点间是松耦合的，各微服务之间可以独立开发、部署和升级，模块化程度进一步提升，从而提高了开发效率和部署速度。
    \item \textbf{隔离性}：每个微服务都是独立自治的系统，一个微服务的故障不会影响其他微服务的运行，更不会导致整个系统的崩溃，可以很好的实现故障隔离，从而提高了系统的可用性。
    \item \textbf{可扩展性}：庞大的单一应用如果出现性能瓶颈，只能对整个应用进行扩容，但是真正的限制可能只是其中一个模块，整体扩展会带来大量的资源浪费；而微服务可以根据实际情况只对真正限制性能的微服务进行弹性扩容，从而提高了系统的可扩展性。
    \item \textbf{异构性}：由于微服务节点间独立、网络通信的特点，只要通过统一的协议通信，不同节点可以采用异构的开发语言、数据库、硬件等，从而可以根据不同的业务需求选择最适合的技术栈，提高了开发的灵活性。
    \item \textbf{简化部署}：传统单一应用的升级部署需要对整个应用重新打包并重新部署，这样非常困难且充满不确定性；而微服务可以对每个微服务进行独立的升级部署，出现了问题容易快速回滚，从而提高了升级部署效率的。
\end{itemize}

但是作为一种分布式的架构，微服务无疑也带来了许多新的挑战，包括服务安全、服务间通信、服务鉴权与认证、服务注册与发现、服务监控与追踪、服务限流与熔断、服务降级与容错、服务负载均衡、服务容器化等，这些挑战都需要通过新的技术手段来解决。本次研究主要聚焦于安全计算的微服务场景，需要着重考虑服务的安全性、可信度和通信效率，因此主要解决服务安全、通信、鉴权与认证方面的问题。

\subsection{平台即服务（PaaS）}

PaaS（Platform-as-a-Service）~\cite{}是云计算场景的一种服务模式，提供了应用程序开发和部署所需的平台和工具，开发者可以使用这些工具和平台来开发、测试和部署自己的应用程序，而无需考虑底层的基础设施和资源管理等问题。PaaS通常提供了操作系统、开发环境、数据库管理系统、Web服务器等平台和工具，这些平台和工具都运行在云计算平台的基础设施上，无需开发者进行维护，使得开发者可以更加专注于应用程序的开发和业务逻辑。PaaS提供的资源可以根据应用需要进行弹性分配和弹性扩容，从而提高了应用程序的可扩展性。

得益于PaaS的便利性，越来越多的企业和开发者选择将自己的微服务应用部署到PaaS平台上，以降低应用开发和部署的成本。但是PaaS作为一种公有云提供服务的方式，部署在其上的应用需要信任PaaS平台的安全性，而传统情况下这一点无法得到保障：一个恶意的或被恶意攻击者劫持的PaaS系统可以在更高的特权级下轻松获取应用的隐私数据。这一点大大限制了PaaS的使用场景，导致涉及隐私数据的公有云使用遭到了严重挑战。

\subsection{可信执行环境（TEE）}

可信执行环境是一种结合硬件和密码学原理的可信计算技术，通过在不可信的环境中创建一个可信的、隔离的飞地（Enclave），通过特殊的硬件指令控制加密数据进出飞地并在其中解密进行计算，达到即使操作系统（OS）也无法获取机密数据的能力，从而保护应用程序的安全性和隐私性。在分布式场景下，TEE通过结合硬件的方式，可以达到安全多方计算（MPC）~\cite{}、同态加密（HE）~\cite{}相似的安全保障，但是由于MPC和HE需要复杂的计算和使用逻辑，效率远远不如TEE。然而，TEE的硬件可能会受到侧信道攻击~\cite{}、时序攻击~\cite{}等物理攻击，从而导致TEE的安全性受到威胁，但是这些攻击可以通过在程序中添加随机噪声~\cite{}来防御，本次研究暂不考虑。

可信执行环境的实现包括Intel的SGX~\cite{}、ARM的TrustZone~\cite{}、AMD的SEV~\cite{}以及RISC-V上开源的Keystone~\cite{}等。由于目前主流的PaaS底层硬件多是Intel架构的，因此我们对于TEE的使用主要聚焦于Intel SGX。SGX（Software Guard Extensions）实现了基于机器安全内存检查机制支持的一组指令集扩展，设计了内存保护和地址映射保护规则，并设计了Remote Attestation协议，由此可以为受保护的代码提供保密性，而不依赖于软件和固件的完整性保护，可以轻松抵御PaaS系统的特权态攻击。

\subsection{库操作系统（Library OS）}

库操作系统（Library Operating System，简称LibOS）是一种将操作系统内核提供的资源管理功能、系统调用等以库的形式提供给应用程序的操作系统，具有模块化、专用化、单地址空间的特点。相比于传统的操作系统，由于功能在库中实现，开发者可以根据自己的需要对库进行定制和扩展，从而使LibOS可以更加轻量级、更加灵活地提供需要的功能，从而提高应用程序的性能和可扩展性。

因为SGX本质上是硬件隔离的内存区域，上面只有很少的库函数，不能提供POSIX接口功能，因此想要将外部程序放到SGX中运行，可以使用LibOS提供运行时环境，达到不需要更改或极少更改源程序的目的。可以在SGX中运行的LibOS有Graphene-SGX~\cite{}、Occlum~\cite{}等。

\subsection{远程验证协议}

远程验证协议是一种用于验证远程实体的安全性和完整性的协议。通常会在一个可信的环境中运行，用来确保远程设备的代码和数据没有被篡改或者受到攻击。

SGX remote attestation~\cite{}是Intel SGX提供的一种远程验证协议，用于证明远程节点身份可信、内容未被篡改、运行在合法的SGX实体中、安全级别正确。由此可以确保计算机平台中运行的程序是预期的版本，其在启动时未被篡改，是由一个受信任的源发布的，并且安全地运行在SGX上。

为了进行远程验证，Intel提供的SGX SDK提供了创建QUOTE的结构，QUOTE中保存了飞地的身份和运行平台的信息；Intel还提供了Intel Attestation Service（IAS），这是一种可以使用组签名方案验证QUOTE真实性的服务~\cite{}。另外，Intel SGX建立了2个识别飞地的度量标准（measurement），分别是飞地身份和密封身份。飞地身份（MRENCLAVE）是一个SHA-256摘要，取自飞地构建过程中所有活动（包括飞地中页面的相对位置、页面的安全标志及页面内容等）的日志；而密封身份包括密封授权机构、产品ID和版本号，密封授权机构通常是飞地的构建者，签署了一个RSA飞地证书（SIGSTRUCT），其中包含MRENCLAVE和验证签名的公钥，验证通过后计算密封授权机构公钥的哈希值，即为MRSIGNER。

在远程验证过程中设计三个参与方：挑战者（Challenger）、被验者（Attester）和Intel Attestation Service（IAS）。挑战者是发起验证的一方，被验者是被验证的一方，IAS是被验者和挑战者之间的信任第三方。

% TODO：插入图片

XXX是SGX remote attestation的过程示意。其中描绘的简化消息流如下：

\begin{itemize}
    \item \textbf{消息 0}：挑挑战者将其公钥发送给被验者，表示开始新的认证过程。被验者使用该公钥创建Diffie-Hellman密钥交换（DHKE）~\cite{}的上下文。% TODO：引用参考uranus这里的引用
    \item \textbf{消息 1}：被验者收到消息0后，将自己的公钥发送给挑战者。
    \item \textbf{消息 2}：挑战者使用DHKE算法导出对称共享密钥（SK），并生成消息2，其中包含挑战者的公钥、两个公钥（挑战者和被验者）的串联签名以及使用共享密钥生成的消息验证码（MAC）。
    \item \textbf{消息 3}：被验者检查消息2并借助Quoting Enclave（QE）创建QUOTO，包含在消息3中，并用SK生成MAC。
    \item \textbf{QUOTE检查}：挑战者验证MAC并将QUOTE发送给IAS。IAS验证QUOTE的签名和结构，然后用认证验证报告（AVR）回答。如果AVR状态为“OK”，则挑战者可以信任QUOTE的内容，并将其与参考值（期望的MRENCLAVE或MRSIGNER）进行比较。
    \item \textbf{消息 4}：此消息是确认认证过程已成功完成，之后挑战者可以将机密信息发送给被验者。
\end{itemize}

在微服务计算平台场景下，SGX remote attestation可以用在微服务节点间首次通信时验证对方的身份和合法性，确保对方身份合法、未被篡改且运行在合法的SGX飞地中。但是想要保证通信安全，还需要确保微服务节点间每次通信的机密性和完整性以及依赖节点间授权的合法性，因此需要使用更多的安全通信协议，例如可以分别使用TLS和OAuth2来解决这两个问题。由此可以结合使用SGX Remote Attentation、TLS和Auth2设计一种综合的远程验证协议。

\subsection{远程过程调用（RPC）}

远程过程调用（Remote Procedure Call，RPC）是一种计算机通信协议，它允许一个计算机程序调用另一个地址空间（通常是远程的）的子程序或函数，就像本地调用一样使用这个函数，而不需要了解底层网络细节。这使得应用程序可以分布在不同的计算机上，通过网络进行通信，实现远程访问和协作。因为RPC具有简单易用、跨语言支持、高性能、轻量级的特点，成为了微服务通信的主要方式。常见的RPC框架有gRPC~\cite{}、Apache Thrift~\cite{}等。

\subsection{Rust语言}

Rust编程语言~\cite{}是一种现代的系统级安全编程语言，由Mozilla开发并开源发布，其设计目标是在提供与C/C++类似的系统级编程能力的同时避免C/C++中常见的安全问题，例如缓冲区溢出、空指针引用等。Rust在编译阶段提供了强大的静态类型安全和内存安全保障，并成功将高级语言的功能性和表现力与无垃圾回收的运行性能相结合。

Rust的所有权模型是其编译时内存安全和管理的关键。在Rust中，每个内存中的对象只能有且只有一个所有者，负责对对象进行析构；当这个对象被移动后，原来的所有者将无法再访问该对象。这种所有权模型可以避免内存泄漏和数据竞争等内存安全问题。Rust还提供了一种内存安全的共享机制，称为借用（borrowing），类似于C++中的引用，但是会有更严格的安全限制。Rust的所有权模型和借用机制可以在编译阶段检查出内存安全问题，而不需要运行时的垃圾回收机制。

Rust还有许多其他特性，例如生命周期分析、零成本抽象、高级模块系统、Cargo管理工具等，这些特性使得Rust具备安全、高效、易用的特点，成为了开发高性能、安全可靠的系统级软件的理想选择。
